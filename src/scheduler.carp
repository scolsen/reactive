(load "src/types.carp")
(load "src/util.carp")
(use Types)
(use Array)
(use Maybe)

;;;; The following differs from Rudal's implementation in that we don't bother
;;;; with a map. Even though run order should not matter, for now I'm assuming
;;;; I/we will want to be able to determine the run order of the propagation
;;;; thunks. If it truly does not matter we can implement maps later.

(defmodule Scheduler

  (deftype (State a) 
    (Done [])
    (Value [a]))

  (def scheduled-propagators (the (Array Propagator) (zero)))
  ;; all propagators ever scheduled during the scheduler's lifetime.
  (def history (the (Array Propagator) (zero))) 
  (def last-value-of-run State.Done)
  
  (private propagators-scheduled?)
  (doc propagators-scheduled? "Returns true if any propagators have been alerted.")
  (sig propagators-scheduled? (Fn [] Bool))
  (defn propagators-scheduled? [] 
    (> (length &scheduled-propagators) 0))

  (private clear-schedule)
  (doc clear-schedule "Reset the list of scheduled propagators.")
  (defn clear-schedule []
    (set! scheduled-propagators (zero)))
  
  (private clear-history)
  (doc clear-history "Reset the scheduler's history.")
  (defn clear-history []
    (set! history (zero)))

  (private insert)
  (doc insert "Add a propagator to an array of propagators. 
  If the propagator is already a member of the array, do nothing.")
  (sig insert (Fn [(Ref (Array Propagator)) (Ref Propagator)] ()))
  (defn insert [propagators propagator]
   (let [names (copy-map &propagator-name propagators)]  
    (match @propagator 
      (Propagator.Propagator name _) 
        (when (Reactive-Util.member? &names &name) 
              (push-back! propagators @propagator))       
      (Propagator.Nil) ())))

  (private run-alerted)
  (doc run-alerted "Run all of the alterted propagators.")
  (sig run-alerted (Fn [] (State a)))
  (defn run-alerted [] 
      (do 
        (clear-schedule)
        (foreach [propagator &scheduled-propagators]
          (do 
            (ignore (match @propagator 
              (Propagator.Propagator _ f) (f)
              (Propagator.Nil) ()))
            (set! scheduled-propagators (remove propagator
            scheduled-propagators))))
        (if (propagators-scheduled?)
            (run-alerted)
            State.Done)))

  ;;;; TODO: Implement an abortion mechanism.
  
  (doc schedule-propagators 
    "Add propagators to the scheduler's array of propagators.
     Also adds the propagators to the scheduler's history.")  
  (sig schedule-propagators (Fn [(Ref (Array Propagator))] ()))
  (defn schedule-propagators [propagators] 
    (foreach [propagator propagators] 
      (do (insert &scheduled-propagators propagator)
          (insert &history propagator))))
  
  (doc schedule-propagator 
    "Add a single propagator to the scheduler's array of propagators.
     Also adds the propagator to the scheduler's history.")  
  (sig schedule-propagator (Fn [(Ref Propagator)] ()))
    (defn schedule-propagator [propagator] 
    (do (insert &scheduled-propagators propagator) 
        (insert &history propagator)))
  
  (doc reschedule
    "Reschedule all the propagators in the scheduler's history.")
  (sig reschedule (Fn [] ()))
  (defn reschedule []
    (schedule-propagators &history))

  (doc start "Initialize the scheduler.")
  (sig start (Fn [] ()))
  (defn start [] 
    (do (clear-schedule)
        (clear-history)
        (set! last-value-of-run State.Done)))

  (doc run-scheduler "Run the scheduler.")
  (sig run-scheduler (Fn [] (State a)))
  (defn run-scheduler [] 
    (do (when (propagators-scheduled?) 
              (set! last-value-of-run (run-alerted)))
      last-value-of-run))
)
