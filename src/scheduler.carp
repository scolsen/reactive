(use Map)
(use Array)

;;;; The following differs from Rudal's implementation in that we don't bother
;;;; with a map. Even though run order should not matter, for now I'm assuming
;;;; I/we will want to be able to determine the run order of the propagation
;;;; thunks. If it truly does not matter we can implement maps later.

(defmodule Scheduler

  (deftype (State a) 
    Done 
    (Value a))

  (def (the (Array (Fn [a] t)) scheduled-propagators) (zero))
  ;; all propagators ever scheduled during the scheduler's lifetime.
  (def (the (Array (Fn [a] t)) history) (zero)) 
  (def last-value-of-run State.Done)
  
  (private propagators-scheduled?)
  (doc propagators-scheduled? "Returns true if any propagators have been alerted.")
  (defn propagators-scheduled? [] 
    (> (length scheduled-propagators) 0))

  (private clear-schedule)
  (doc clear-schedule "Reset the list of scheduled propagators.")
  (defn clear-schedule []
    (set! scheduled-propagators (zero)))
  
  (private clear-history)
  (doc clear-history "Reset the scheduler's history.")
  (defn clear-history []
    (set! all-propagators (zero)))

  (private insert)
  (doc insert "Add a propagator to an array of propagators. 
  If the propagator is already a member of the array, do nothing.")
  (sig insert (Fn [(Array (Fn [a] t)) (Fn [a] t)] ()))
  (defn insert [propagators propagator]
    (match (index-of propagators propagator)
      (Nothing) (push-back! propagators propagator) 
      (Just x) ()))

  (private run-alerted)
  (doc run-alerted "Run all of the alterted propagators.")
  (sig run-alerted (Fn [] (State a)))
  (defn run-alerted [] 
    (let [jobs scheduled-propagators] 
      (do 
        (clear-schedule)
        (foreach [propagator jobs]
          (propagator))
        (if (propagators-scheduled?)
            (run-alerted)
            (State.Done)))))

  ;;;; TODO: Implement an abortion mechanism.

  (doc schedule 
    "Add one or more propagators to the scheduler's array of propagators.
     Also adds the propagators to the scheduler's history.")
  (definterface schedule (Fn [a] ()))
  
  (defmodule Array
    (sig schedule (Fn [(Array (Fn [a] t))] ()))
    (defn schedule [propagators] 
      (foreach [propagator propagators] 
        (insert scheduled-propagators propagator)
        (insert history propagator)))
  ) 
  
  (defmodule Function
    (sig schedule (Fn [(Fn [a] t)] ()))
    (defn schedule [propagator] 
    (do (insert scheduled-propagators propagator) 
        (insert history propagator))) 
  )  

  (doc reschedule
    "Reschedule all the propagators in the scheduler's history.")
  (sig reschedule (Fn [] ()))
  (defn reschedule []
    (schedule history))

  (doc start "Initialize the scheduler.")
  (sig start (Fn [] ()))
  (defn start [] 
    (do (clear-schedule)
        (clear-history)
        (set! last-value-of-run (State.Done))))

  (doc run-scheduler "Run the scheduler.")
  (sig run-scheduler (Fn [] (State a)))
  (defn run-scheduler [] 
    (do (if (propagators-alerted?) 
            (set! last-value-of-run (run-alerted)))
      last-value-of-run))
)
