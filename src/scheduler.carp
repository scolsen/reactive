(use Array)
(use Maybe)

;;;; The following differs from Rudal's implementation in that we don't bother
;;;; with a map. Even though run order should not matter, for now I'm assuming
;;;; I/we will want to be able to determine the run order of the propagation
;;;; thunks. If it truly does not matter we can implement maps later.

(defmodule Scheduler

  (deftype (State a) 
    Done 
    (Value [a]))

  (def scheduled-propagators (the (Array (Fn [] ())) (zero)))
  ;; all propagators ever scheduled during the scheduler's lifetime.
  (def history (the (Array (Fn [] ())) (zero))) 
  (def last-value-of-run State.Done)
  
  (private propagators-scheduled?)
  (doc propagators-scheduled? "Returns true if any propagators have been alerted.")
  (sig propagators-scheduled? (Fn [] Bool))
  (defn propagators-scheduled? [] 
    (> (length &scheduled-propagators) 0))

  (private clear-schedule)
  (doc clear-schedule "Reset the list of scheduled propagators.")
  (defn clear-schedule []
    (set! scheduled-propagators (zero)))
  
  (private clear-history)
  (doc clear-history "Reset the scheduler's history.")
  (defn clear-history []
    (set! history (zero)))

  (private insert)
  (doc insert "Add a propagator to an array of propagators. 
  If the propagator is already a member of the array, do nothing.")
  (sig insert (Fn [(Ref (Array (Fn [] ()))) (Ref (Fn [] ()))] ()))
  (defn insert [propagators propagator]
    (match (Array.index-of propagators propagator)
      (Nothing) (push-back! propagators @propagator) 
      (Just x) ()))

  (private run-alerted)
  (doc run-alerted "Run all of the alterted propagators.")
  (sig run-alerted (Fn [] (State a)))
  (defn run-alerted [] 
      (do 
        (clear-schedule)
        (foreach [propagator &scheduled-propagators]
          (~propagator))
        (if (propagators-scheduled?)
            (run-alerted)
            (State.Done))))

  ;;;; TODO: Implement an abortion mechanism.

  (doc schedule 
    "Add one or more propagators to the scheduler's array of propagators.
     Also adds the propagators to the scheduler's history.")
  (definterface schedule (Fn [a] ()))
  
  (defmodule Array
    (sig schedule (Fn [(Array (Fn [] t))] ()))
    (defn schedule [propagators] 
      (foreach [propagator &propagators] 
        (insert &scheduled-propagators &propagator)
        (insert &history &propagator)))
  ) 
  
  (defmodule Function
    (sig schedule (Fn [(Fn [] t)] ()))
    (defn schedule [propagator] 
    (do (insert &scheduled-propagators &propagator) 
        (insert &history &propagator))) 
  )  

  (doc reschedule
    "Reschedule all the propagators in the scheduler's history.")
  (sig reschedule (Fn [] ()))
  (defn reschedule []
    (schedule history))

  (doc start "Initialize the scheduler.")
  (sig start (Fn [] ()))
  (defn start [] 
    (do (clear-schedule)
        (clear-history)
        (set! last-value-of-run (State.Done))))

  (doc run-scheduler "Run the scheduler.")
  (sig run-scheduler (Fn [] (State a)))
  (defn run-scheduler [] 
    (do (if (propagators-alerted?) 
            (set! last-value-of-run (run-alerted)))
      last-value-of-run))
)
